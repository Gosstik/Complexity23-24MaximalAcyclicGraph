%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% To reuse that document:
% 1) Change Source/TitlePage.tex
% 2) Change Headings/Geometry.tex (headers and footers)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper, 12pt, oneside]{extarticle}  % "extarticle" instead "article" to use 14pt font

\input{Headings/Packages}
%%%%%%%%%% Hack, чтобы не удалять комментарии. %%%%%%%%%%
\newif\ifdraft{}
% \drafttrue
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{Headings/Shortcuts}
\input{CustomHeadings/Geometry}
\input{Headings/TheoremStyles}
\input{Headings/Misc}
\input{CustomHeadings/Custom}
\input{CustomHeadings/Hyphenation}

\bibliography{bibliography}

%%%%%%%%%%%%%%% Specific for that project %%%%%%%%%%%%%%%
% \newcommand{\sepsection}[1]{{\large\bfseries Specific new command}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

% \include{bibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Title page.
\SetTitlePageSettings

\begin{adjustwidth}{-5mm}{-5mm} % to be independent of file left-right margings
  \begin{center}
    \LARGE{Approximations for the maximum acyclic subgraph problem} \\
    \vspace{8pt}
    \large{Rafael Hassin *, Shlomi Rubinstein} \\
    \vspace{3pt}
    \small\textit{Department of Statistics and Operations Research, School of Mathematical Sciences, Tel-Aviv University, Tel-Aviv 69978, Israel} \\
    \vspace{3pt}
    \small{Communicated by S. Zaks; received 9 May 1993; revised 9 February 1994}
  \end{center}
\end{adjustwidth}

\vspace{15pt}

\begin{adjustwidth}{-5mm}{-5mm} % to be independent of file left-right margings
  \begin{center}
    \LARGE{Перевод} \\
    \vspace{8pt}
    \large{Егор Вашкевич} \\
    \vspace{3pt}
    \small\textit{физтех-школа ФПМИ МФТИ}
  \end{center}
\end{adjustwidth}

\vspace{15pt}

\begin{adjustwidth}{-5mm}{-5mm} % to be independent of file left-right margings
  \begin{center}
    \LARGE{Приближения для задачи о максимальном ациклическом подграфе} \\
    \vspace{8pt}
    \large{Рефаэль Хассин *, Шломи Рубинштейн} \\
    \vspace{3pt}
    \small\textit{Факультет статистики и операционных исследований, Школа математических наук, Тель-Авивский университет, Тель-Авив 69978, Израиль} \\
    \vspace{3pt}
    \small{Передано С. Заксом; получено 9 мая 1993; пересмотрено 9 Февраля 1994}
  \end{center}
\end{adjustwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{Аннотация}

Пусть дан граф $G = (V, E)$, тогда \textit{задача поиска максимального ациклического подграфа} состоит в вычислении подмножества рёбер $A'$ максимального размера или общего веса так, чтобы $G'=(V, A')$ был ациклическим. Мы обсудим несколько алгоритмов приближённых решений для этой задачи. Нашим главным результатом будет алгоритм, работающий за  $O(|A| + d_{max}^3)$, который выдает решение с долей как минимум
$\frac{1}{2} + \Omega(\frac{1}{\sqrt{d_{max}}})$ от числа рёбер в оптимальном решении. Здесь $d_{max}$ --- максимальная степень вершины в $G$.
\\
\\
\small\textit{Ключевые слова: Анализ алгоритмов; Комбинаторные задачи}

% \newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Введение}

Пусть дан граф $G = (V, A),\ V = \{1,\ldots, n\}$ с весами рёбер $w_{ij} > 0, (i, j) \in A$. \textit{Задача поиска максимального ациклического подграфа} состоит в том, чтобы найти подмножество $A' \subset A$ такое, что $G' = (V, A')$ является ациклическим и значение $w(A') = \sumlim{(i,j)\in A'}{} w_{ij}$ максимально. В альтернативной постановке этой задачи (поиск минимального множества обратных рёбер\footnote{В оригинале --- minimum feedback arc set problem (прим. перев.).}) требуется найти подмножество минимального веса $A'' \subset A$ такое, что каждый (направленный) цикл $G$ содержит по крайней мере одно ребро в $A''$. Задача является $\mathsf{NP}$-сложной [11]. Она принадлежит к классу задач "удаления рёбер" [17, 21]. Было показано, что она является полной для класса задач оптимизации перестановок,
$\mathsf{MAX\ SNP}[\pi]$, определенном в [19], которые можно приближённо вычислить с фиксированной погрешностью.

Задача полиномиально разрешима, когда $G$ планарный ([4,12,15] и глава 8.4 в [8]). Наилучшая сложность этих алгоритмов --- $O(n^3)$ [5] и $O(n^{\frac{5}{2}} \log(nW))$, где $W$ --- наибольшее значение веса ребра (предполагается, что веса являются целыми) [6]. Задача также полиномиально разрешима для более общего класса $K_{3,3}$-свободных графов [18] и классов приводимых потоковых графов [20] и слабо ациклических графов [7]. Вариация задачи, в которой целью является минимизация наибольшего значения выходной степени вершины в подграфе $(V,A'')$, может быть решена за линейное время [16].

Задача имеет множество применений, таких как упорядочение альтернатив путем группового голосования,
определение иерархии секторов экономики, определение родственных связей, анализ систем с обратной
связью и определенных проблем с планированием [3,14,20]. Флуд [3] использовал связь задачи с квадратичным
присваиванием для разработки эффективного метода ветвей и границ. Юнгер [14] изучал многогранник ациклического подграфа.

Задачи о максимальном ациклическом подграфе и о минимальном множестве обратных рёбер эквивалентны по отношению к их оптимальному решению. Однако полиномиальные аппроксимации с ограниченной ошибкой известны только для постановки проблемы с максимальным ациклическим подграфом. Простейший алгоритм следующий [9]: Пусть $A_1 = \condset{(i, j) \in A}{i < j},\ A_2 = \condset{(i, j) \in A}{i > j}$. Очевидно, что и $(V, A_1)$, и $(V, A_2)$ являются ациклическими и, поскольку $A1 \cup A2 = A \ \Rightarrow \ \max\set{w(A_1), w(A_2)} \ge 0.5w(A)$. Следовательно, это 0.5-приближение к задаче. Заметим, что алгоритм имеет линейную сложность.

Корте и Хаусманн [13] доказали, что жадный алгоритм (т.е. построение решения путем многократного выбора ребра максимального веса, которое не образует направленный цикл с уже выбранными ребрами) не гарантирует какой-либо фиксированной ошибки.

Более сложный алгоритм для невзвешенной постановки задачи был предложен Бергером и Шором [2]. Они отмечают, что без ограничения общности мы можем предположить, что $G$ не имеет циклов длины 2, поскольку любая оценка, которая может быть получена при этом предположении, также может быть получена без него путем простой модификации алгоритма. Затем они разрабатывают алгоритм, создающий ациклический подграф из как минимум $(\frac{1}{2} + \Omega(\frac{1}{\sqrt{d_{max}}}))|A|$ рёбер где $d_{max}$ --- максимальная степень вершины $G$. Даже когда существуют циклы длины два, решение содержит по меньшей мере $(\frac{1}{2} + \Omega(\frac{1}{d_{max}}))$ долю рёбер от их количества в оптимальном решении. Алгоритм работает за время $O(|A||V|)$.

В этой статье мы исследуем различные алгоритмы для решения задачи. Наш основной вклад --- это алгоритм для задачи без весов, который гарантирует оценку, аналогичную той, которая была получена Бергером и Шором, но с временной сложностью $O(|A| + d_{max}^3)$, которая лучше, чем $O(|A||V|)$ в определенных случаях.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Получение решения из перестановки}

Назовем ациклический подграф $G$ максимальным, если он строго не содержится в другом ациклическом подграфе $G$. Поскольку мы предполагаем, что веса рёбер положительны, максимальный ациклический подграф также максимален. Перестановка $\pi$ из $\set{1, \ldots, n}$ индуцирует ациклический подграф $G_{\pi} = (V, A_{\pi})$, где $A_{\pi} = \condset{(i, j) \in A}{\pi(i) < \pi(j)}$. Заметим, что $G_{\pi}$ может быть не максимальным, если он не связен. Однако каждый максимальный ациклический подграф $G$ индуцируется некоторой перестановкой. (Всегда можно перенумеровать вершины ациклического графа так, чтобы каждое ребро $(i, j)$ в нем удовлетворяло $i < j$, и, если граф максимален, тогда он индуцируется этой перестановкой.) Следовательно, задача о максимальном ациклическом подграфе --- это в точности задача вычисления перестановки, индуцированный подграф которой имеет максимальный вес.

Для начала напишем псевдо-код алгоритма, который генерирует перестановку $\pi$, такую что $w(A_{\pi}) > 0.5w(A)$. Для $i \in V$ и $S \subset V$, пусть $w_{i}^{in}(S) = \sumlim{j \in S}{}w_{ij}, \ w_{i}^{out}(S) = \sumlim{j \in S}{}w_{ij}$.

\begin{algo}\label{alg:1}\ \par
  \begin{enumerate}[label=\arabic*)]
    \item Положим $S=V, l=1, u=n$.
    \item Возьмём $i \in S$. Присвоим $S \leftarrow S \setminus \set{i}$. Если $w_{i}^{in}(S) \le w_{i}^{out}(S)$, присвоим $\pi(i) = l,\ l \leftarrow l+1$. Если $w_{i}^{in}(S) > w_{i}^{out}(S)$, присвоим $\pi(i) = u,\ u \leftarrow u-1$.
    \item Если $u \ge l$, выполнить шаг 2. Иначе остановиться и вернуть $\pi$.
  \end{enumerate}
\end{algo}

Вес рёбер, сохраняемых алгоритмом, составляет по меньшей мере половину от общего веса $A$, поскольку это свойство выполняется на каждой итерации относительно рёбер, инцидентных вершине $i$ в подграфе, индуцированном $S$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Рандомизация}

Трудность в получении лучшей оценке ошибки, чем 0.5, в случае применения простых конструктивных алгоритмов возникает, когда $w_{i}^{in}(S) \approx w_{i}^{out}(S)$ для большого количества вершин. Мы постараемся преодолеть трудности, связанные с такой ситуацией, и улучшить оценку для задачи с невзвешенным графом, считая максимальную степень вершины графа параметром.

Начнём с представления рандомизированного алгоритма. Он отличается от предложенного в [2], но обеспечивает аналогичную оценку. Без ограничения общности можем считать, что $G$ не содержит циклов длины 2. Если он содержит циклы длины 2, как это сделано в [2], то они могут быть временно удалены до выполнения алгоритма. Любая перестановка приведет к получению графа ровно с одним ребром из каждого такого цикла.

\begin{algo}\label{alg:2}\ \par
  \begin{enumerate}[label=\arabic*)]
    \item Разделить $V$ на два подмножетсва $V_1$ и $V_2$, присваивая вершину к каждому множеству случайно с вероятностью 0.5. Пусть $A_r = \set{(i,j)|\ i, j \in V_r}$. Выполнить шаг 2 для для $r=1,2$.
    \item Создать перестановку $\pi_r$ вершин в $V_r$, применяя алгоритм \ref{alg:1} к $(V_r, A_r)$. Вершины выбираются в порядке возрастания их индексов.
    \item Определить конечную перестановку, выбирая между $(\pi_1, \pi_2)$ и $(\pi_2, \pi_1)$ ту перестановку, которая индуцирует подграф с бóльшим количеством рёбер.
  \end{enumerate}
\end{algo}

\begin{theorem}\label{th:3}
  Пусть $APX$ --- матожидание числа рёбер в решении, полученном алгоритмом \ref{alg:2}. Тогда
  \[APX = \left(0.5 + \Omega\left(\frac{1}{\sqrt{d_{max}}}\right)\right)|A|\]
\end{theorem}
\begin{proof}
  Рассмотрим вершину $i\in V_r$. Обозначим:
  \begin{align*}
     & D_{i}^{in} = \abs{(j, i) \in A: j > i},       \\
     & D_{i}^{out} = \abs{(i, j) \in A: j > i},      \\
     & d_{i}^{in} = \abs{(j, i): j \in V_r, j > i},  \\
     & d_{i}^{out} = \abs{(i, j): j \in V_r, j > i}.
  \end{align*}

  Случайная величина $d_{i}^{in}$ имеет биномиальное распределение с параметрами $(0.5, D_{i}^{in})$, так как для любого ребра, инцидентного $i$, вероятность того, что его второй конец также будет из $V_r$, составляет 0.5. Аналогично $d_{i}^{out}$ имеет биномиальное распределение с параметрами $(0.5, D_{i}^{out})$.

  Без ограничения общности будем считать, что $D_{i}^{in} \ge D_{i}^{out}$. Для $a \ge 0$
  \[
    P \equiv \text{Pr}(\abs{d_{i}^{in} - d_{i}^{out}} \ge a) \ge \text{Pr}(d_{i}^{in} - d_{i}^{out} \ge a).
  \]

  По нашему предположению $G$ не содержит циклов длины 2, $d_{i}^{in}$ и $d_{i}^{out}$ --- независимые случайные величины. Рассмотрим 2 независимые случайные величины $X_1, X_2$, имеющие биномиальное распределение с параметрами $\pars{0.5, D_{i}^{in}}$. Тогда
  \begin{align*}
    P & \ge Pr\pars{X_1 - X_2 \ge a}
    \\
      & \ge Pr\pars{X_1 \ge 0.5D_{i}^{in} + a, X_2 \le 0.5D_{i}^{in}}
    \\
      & = 0.5Pr\pars{X_1 \ge 0.5D_{i}^{in} + a},
  \end{align*}
  где первое следует из предположения $D_{i}^{in} \ge D_{i}^{out}$. Пусть $a$ --- дисперсия $X_1$, $a = \frac{1}{2}\pars{D_{i}^{in}}^{\frac{1}{2}}$. Получаем, что для некоторой константы $\beta > 0$\footnote{Для случайной величины $X$, имеющей биномиальное распределение с параметрами $(p, n): p \le 0.5$ вероятность $p_n = Pr\pars{X - np \ge (np(1-p))^{\frac{1}{2}}}$ положительна при любых значениях $n$. $p_n$ сходится к положительному пределу в силу центральной предельной теоремы и поэтому при $ n = 1, 2, \ldots$ имеем $\inf\limits_{n} p_n > 0$.}:
  \[Pr(\abs{d_{i}^{in} - d_{i}^{out}} \ge a) \ge \beta\]
  Пусть $D_i = D_i^{in} + D_i^{out}$, тогда $D_I^{in} \ge \frac{D_i}{2}$ и $a = \Omega(\sqrt{D_i}) = \Omega \pars{\frac{D_i}{\sqrt{D_i}}} = \Omega \pars{\frac{D_i}{\sqrt{d_{max}}}}$.

  Шаг 2 присваивает вершине $i$ следующую более низкую или более высокую позицию в перестановке в соостветствии со знаком разности $d_i^{in} - d_i^{out}$. Общее число рёбер, порождённое $\pi_r$:
  \begin{align*}
    \sumlim{i\in V_r}{} \max(d_i^{in}, d_i^{out}) & = \sumlim{i\in V_r}{} \pars{\pars{\frac{d_i^{in} + d_i^{out}}{2}} + \frac{1}{2}\abs{d_i^{in} - d_i^{out}}}
    \\
                                                  & = 0.5|A_r| + 0.5\sumlim{i\in V_r}{\abs{d_i^{in} - d_i^{out}}}.
  \end{align*}
  Приходим к заключению, то матожидание числа рёбер, порождённых $\pi_r$, удовлетворяет соотношению
  \[ASX_{r} = 0.5|A_r| + \Omega\pars{\sumlim{i}{}\frac{D_i}{\sqrt{d_{max}}}}.\]
  Поскольку $\sumlim{i}{}D_i = |A|$, то
  \[APX_1 + APX_2 = 0.5\pars{|A_1| + |A_2|} + \Omega\pars{\frac{|A|}{\sqrt{d_{max}}}}\].

  Шаг 3 алгоритма упорядочивает 2 частичные перестановки так, что итоговый индуцированный подграф содержит как минимум половину рёбер, соединяющих вершины из $V_1$ с вершинами из $V_2$. Отсюда следует утверждение теоремы.
\end{proof}

\begin{remark}\label{rem:4}
  Матожидание числа рёбер, получаемых в результате алгоритма, также составляет $\pars{0.5 + \Omega \pars{\frac{1}{\bar{d}}}}|A|$. где $\bar{d} = \frac{2|A|}{n}$ --- средняя степень в $G$. Эта оценка получается исходя из того, что матожидание числа рёбер, в дополнение к $0.5|A|$, полученном на шаге 3, равно как минимум одному для каждой вершины. Эта оценка может быть лучше, чем указанная в теореме, когда средняя степень ограничена, а максимальная --- нет.
\end{remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Дерандомизация}

Теперь мы опишем детали, необходимые для эффективного выполнения дерандомизации с помощью метода условных вероятностей (см., например, [1]). Используя этот метод, мы превращаем наш рандомизированный алгоритм в детерминированный с той же временной асимптотикой.

Вместо случайной генерации $V_1, V_2$ в алгоритме \ref{alg:2}, метод последовательно присваивает по одной вершине за раз одному из подмножеств, так что матожидание размера решения, полученного при продолжении случайного вычисления с этого момента, максимизируется. Причина в том, что матожидание размера случайного решениия --- это среднее двух полученных матожиданий, обусловленных присваиванием текущей вершины. Присваивание её множеству, дающему большее значение, гарантирует, по крайней мере, безусловное матожидание.

Заметим, что, исходя из доказательства теоремы \ref{th:3}, член $\Omega\pars{\frac{1}{\sqrt{d_{max}}}}|A|$ получается из анализа матожидания количества рёбер, полученных в множествах $V_1$ и $V_2$. Шаг 3 алгоритма
\ref{alg:2} гарантирует половину рёбер между множествами (и если мы просто рассмотрим матожидания, то оба
$(\pi_1,\pi_2)$ и $(\pi_2,\pi_1)$ подходят под условия теоремы). Теперь покажем, как приведенное выше условие может быть гарантировано детерминистически. На шаге 3 полное решение будет иметь $\pars{0.5 + \Omega\pars{\frac{1}{\sqrt{d_{max}}}}}|A|$ рёбер.

Предположим, что каждая из вершин $1,\ldots,k-1$ уже были присвоены к $V_1$ или $V_2$. Теперь покажем, как эффективно вычислить матожидание количества рёбер в этих наборах, полученных на шаге 2 алгоритма \ref{alg:2}, когда $V_1$, $V_2$ заполняются случайным присваиванием вершин
$k,\ldots,n$. Как и в доказательстве теоремы \ref{th:3}, мы связываем каждое ребро с той его вершиной, у которой индекс меньше.

Рассмотрим данную вершину $i \in \set{1,\ldots,k-1}$. Предположим, что она была присвоена к $V_r$. Очевидным образом алгоритм \ref{alg:2} гарантирует, что приблизительное решение будет содержать по крайней мере половину рёбер внутри $V_r$ из тех, которые связаны с $i$. Сейчас нас интеремует вычисление матожидания количества дополнительных таких рёбер, которые будут содержаться в нашем решении, учитывая первоначальное присваивание первых $k-1$ вершин. Пусть $E(x_i, y_i, z_i)$ обозначает матожидание количества таких дополнительных рёбер, где
\begin{align*}
  x_i & = \abs{(i,j): j \in V_r, i < j < k} - \abs{(i,j): j \in V_r, i < j < k},
  \\
  y_i & = \abs{(i,j): j \ge k},
  \\
  z_i & = \abs{(i,j): j \ge k}.
\end{align*}

Тогда
\begin{align*}
   & E(x, 0, 0) = 0.5|x|,                \\
   & x = \ldots, -2, -1, 0, 1, 2, \ldots
\end{align*}
и остальные значения можно вычислить рекурсивно следующим образом:
\begin{align*}
  E(x,y,0) & = 0.5E(x+1, y-1, 0) + 0.5E(x, y-1, 0),          \\
  E(x,y,z) & = 0.5E(x, y, z-1) + 0.5E(x-1, y, z-1), z \ge 1.
\end{align*}

Рекурсия может быть применена путем вычисления $E(x, y, 0)$ для фиксированного значения $y$ и всех значений $x$, начиная с $y = 0$, затем $y = 1$ и так далее. После этого $E(x, y, z)$ вычисляется для фиксированного $z$ и всех значений $x,y$, начиная с $z = 1$, затем $z = 2$ и так далее. Общие сложность вычисления этих
значений для $x=-d_{max},\ldots,d_{max},\quad y = 0,\ldots,d_{max}, \quad z=0,\ldots,d_{max}$ составляет $O\pars{d_{max}^3}$, где $d_{max}$ --- максимальная степень вершины в $G$.

Ожидаемый выигрыш в рёбрах, связанных с вершинами $i \ge k$, равен просто $E(0, y_i, z_i)$.

Заметим, что приведённые выше матожидания справедливы в независимости от порядка, в котором вершины рассматриваются для объединения двух множеств.

Ожидаемый размер решения, обусловленный заданным частичным распределением вершин по двум подмножествам, равен $0.5|A| + \sumlim{i=1}{k-1}E(x_i,y_i,z_i) + \sumlim{i=k}{n}E(0, y_i, z_i).$

Всякий раз, когда рассматривается неприсвоенная вершина, сравниваются две альтернативы для ее присвоения. Каждая альтернатива влияет на значение $(x, y, z)$ своих соседей, а затем выполняется лучшее присваивание и вычисляются пересмотренные значения соседей. Общее время, затраченное на внесение этих изменений и сравнение
матожиданий решения, связанных с двумя альтернативами каждой вершины, равно $O(|A|)$.

Таким образом, вычисление значений $E$, определяющих отнесение к одному из двух множетсв, а также выполнение шагов 2 и 3 алгоритма \ref{alg:2} занимают $O\pars{d_{max}^3 + |A|}$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Конструктивные алгоритмы}

Мы упоминали, что 0.5-приближение может быть получено путём сравнения графов, определенных любой перестановкой и обратной к ней. Далее можно показать, что лучшая оценка не может быть получена путем выбора любого полиномиального множетсва перестановок (независимо от конкретного вида задачи) с последующим сравниванием решений, которые они дают. Поэтому теперь перейдем к исследованию методов, которые генерируют перестановку в зависимости от конкретной постановки задачи.

Нашим основным инструментом будет алгоритм \ref{alg:1}. Заметим, что он не определяет порядок, в котором рассматриваются вершины на шаге 2. Рассмотрим некоторые "примечательные" правила для исследования вершин, а также приведём "плохой пример" для каждого из них. Все плохие примеры описывают невзвешенные постановки задачи.

Напомним, что $w_i^{in}(S) = \sumlim{j\in S}{}w_{ji},\quad w_i^{out}(S) = \sumlim{j\in S}{}w_{ij}$. Пусть $W_i(S) = \max\set{w_i^{in}(S), w_i^{out}(S)}$. Наше первое правило получает на каждой итерации максимально возможный вес:

\begin{algo}\label{alg:5}\ \par
  На шаге 2 алгоритма \ref{alg:1} выбирать вершину $i\in S$ с максимальным значением $W_i(S)$.
\end{algo}

\begin{example}
  Пусть $n=2k+1$ и $A=\condset{(j,k+1)}{j = 1,\ldots,k} \cup \condset{(k+1,j)}{j=k+2,\ldots,2k+1}$. Граф ациклический и оптимальное решение содержит $A$. Однако алгоритм \ref{alg:5} начнет с выбора $k+1$ и присвоит $\pi(k+1)$ либо 1, либо $n$, таким образом потеряв половину рёбер.
\end{example}

Пусть $w_i(S) = min\set{w_i^{in}(S), w_i^{out}(S)}$. Наше второе правило аналогично тому, которое использовали Лин и Сахни [16], чтобы решить их проблему с узким местом. Это минимизирует на каждой итерации вес потерянных рёбер:

\begin{algo}\label{alg:7}
  На шаге 2 алгоритма \ref{alg:1} выбирать вершину $i\in S$ с наименьшим значением $w_i(S)$.
\end{algo}

\begin{example}\label{examp:8}
  Пусть $n=k^2, V=V_1 \cup V_2 \cup \ldots \cup V_k$, где $V_i = \set{(i-1)k + 1,\ldots,ik}, i=1,\ldots,k$. Пусть $A = \condset{(p,q)}{p \in V_i, q \in V_{i+1}, i=1,\ldots,k-1} \cup \condset{(p,q)}{p \in V_k, q \in V_1}$. Заметим, что $A \setminus \condset{(p, q)}{p \in V_k, q \in V_1}$ является ациклическим, и
  оптимальное решение содержит $k^2(k-1)$ рёбер. Однако возможна следующая последовательность выборок при использовании алгоритма \ref{alg:7}. Первоначально $S=V$ и $w_i(S)=k$ для всех $i \in V$. Положим $\pi(1)=1$. Теперь, $S=V\setminus\set{1}, w_i(S) = k-1$ для вершин $i$ в $V_2$ и $V_k$, в то время как $w_i(S)=k$ для всех остальных вершин $S$. Вершина $k+1 \in V_2$ может быть выбрана следующей, а $\pi(k+1)$ будет присвоено значение 2. Кандидатами для отбора теперь являются вершины в $V_1, V_2, V_3$ и $V_k$. Алгоритм сейчас может присвоить $\pi(2k + 1) = 3$, затем $\pi(3k + 1) = 4$ и так далее, пока $\pi((k-1)k + 1)$ не будет присвоено значение $k$. На текущий момент в $S$ осталось $k-1$ вершин из каждого множества. Алгоритм может продолжить выбор вершин в следующем порядке: $(2, k+2, 2k+2,\ldots, (k-1)k + 2, 3, k+3, \ldots)$. Таким образом, полученное решение содержит $\frac{k^2(k + 1)}{2}$ ребра вида
  $(ik + j, (i + 1)k + l)$ для $l \ge j$. Асимптотически это всего лишь половина оптимального значения.
\end{example}

Пусть $\widehat{w}_i(S) = \abs{w_i^{in}(S) - w_i^{out}(S)}$. Наше третье правило максимизирует на каждой итерации превышение полученного веса над потерянным.

\begin{algo}\label{alg:9}
  На шаге 2 алгоритма \ref{alg:1} выбирать вершину $i \in S$ с максимальным значением $\widehat{w}_i(S)$.
\end{algo}

\begin{example}
  Пусть $n=2k+3, A=\condset{(j, k+1)}{ j=1,\ldots,k} \cup \condset{(k+1,j)}{j=k+2,\ldots, 2k+3}$. Тогда вершина $k+1$ изначально имеет $\widehat{w}_{k+1}(V)=2$, в то время как все остальные вершины имеют $\widehat{w}_i(S)=1$. Следовательно, $k+1$ будет выбрана первой в алгоритме \ref{alg:9} и количество потерянных рёбер в решении асимптотически равно $\frac{|A|}{2}$.
\end{example}

Пусть $r_i(S) = \max\set{\frac{w_i^{out}(S)}{w_i^{in}(S)}, \frac{w_i^{in}(S)}{w_i^{out}(S)}}$. Наше четвертое правило максимизирует на каждой итерации отношение полученного веса к потерянному:

\begin{algo}\label{alg:11}
  На шаге 2 алгоритма \ref{alg:1} выбирать вершину $i \in S$ с наибольшим значением $r_i(S)$.
\end{algo}

\begin{example}
  Ещё раз рассмотрим граф из примера \ref{examp:8}. Оптимальное решение состоит из $k^2(k-1)$
  рёбер, например $\condset{(i, j)}{i\in V_l, j \in V_{l+1}, l=1,\ldots, k-1}$. Алгоритм \ref{alg:11} может выбрать вершину из $V_1$, затем из $V_2, V_3,\ldots, V_{k-2}$, а затем в циклическом порядке множеств, начиная с $V_{k-1}$ по две вершины из каждого подмножества. Выбранная перестановка описана для $k=6$ в следующей таблице:
  \begin{align*}
    V_1 &  & V_2 &  & V_3 &  & V_4 &  & V_5 &  & V_6 \\
    1   &  & 2   &  & 3   &  & 4   &  & 5   &  & 7   \\
    9   &  & 11  &  & 13  &  & 15  &  & 6   &  & 8   \\
    10  &  & 12  &  & 14  &  & 16  &  & 17  &  & 19  \\
    21  &  & 23  &  & 25  &  & 27  &  & 18  &  & 20  \\
    22  &  & 24  &  & 26  &  & 28  &  & 29  &  & 31  \\
    33  &  & 34  &  & 35  &  & 36  &  & 30  &  & 32
  \end{align*}
  Эта перестановка приводит к решению с $\frac{k(k+1)}{2}$ рёбрами, идущими от вершины в $V_l$ к вершине в
  $V_{l+1}$ для $l=1,\ldots,k$. Общее число рёбер, выбранных алгоритмом \ref{alg:11}, равно $\frac{k^2(k+1)}{2}$, а отношение оптимальных решений к приближенным асимптотически равно 0.5.
\end{example}

Теперь опишем другой подход к генерации перестановки. Вместо определения точного значения $\pi(i)$ на шаге 2 определим только относительное расположение $i$ относительно вершин, которые уже были исследованы. Таким образом, на каждом этапе нам задается (общий) порядок на множестве $Q=V\setminus S$. Выбираем $i \in S$ и выбираем для него наилучшее местоположение относительно этого порядка. В любой заданной точке выполнения алгоритма обозначим символом $\prec$ порядок, определённый на подмножестве $V$, просмотренном на данный момент. В частности, $k \preceq j$ означает, что $k$ --- это либо $j$, либо вершина, присвоенная предшествующей $j$.

\begin{algo}\label{alg:13}\ \par
  \begin{enumerate}[label=\arabic*)]
    \item Выберем $(i,j) \in A$. Пусть $Q={i,j}, i \prec j, S = V \setminus Q$.
    \item Полагаем, что данный шаг достигнут с порядком $\prec$ на $Q$. Выберем $i \in S$ и множество $S \leftarrow S \setminus i$. Вычислим для каждого $j \in Q$
          \[D_j = \sumlim{k|k\preceq j}{}w_{ki} + \sumlim{K|j\preceq k}{}w_{ik}.\]
          Положим $D_0 = \sumlim{j \in Q}{} w_{ij}$, $D_l = \max\condset{D_J}{j \in Q}$. Если $D_l \ge D_0$, расширим $\prec$ путём добавления таких $i$, которые являются непосредственным преемником $l$. Если $D_l < D_0$, расширим $\prec$ путём добавления $i$ в качестве первого элемента.
    \item Если $S = \varnothing$, остановиться. Иначе присвоить $Q \leftarrow Q \cup \set{i}$ и перейти на шаг 2.
  \end{enumerate}
\end{algo}

\begin{example}
  Пусть $A = \set{(1,n)} \cup \condset{(n,j)}{j= 2,\ldots, n-1} \cup \condset{(j,1)}{j=1,\ldots,n-1}$. Если алгоритм \ref{alg:13} начинается с $(1,n)$, то как минимум половина остальных рёбер должны быть потеряны. Таким образом, результатом будет $n-1$ ребро, в то время как оптимальное решение содержит $2(n-2)$ рёбер в $A \setminus (1,n)$.
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Локальный поиск}

Общая идея локального поиска включает определение окрестности для каждого возможного решения задачи. Затем текущее решение заменяется лучшим решением из его окрестности, если такое решение существует. В противном случае алгоритм останавливается с текущим ("локально оптимальным") решением.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Мы считаем довольно естественным определять окрестности в отношении перестановок. Пусть $V_{\pi}$ --- окрестность $\pi$.

\begin{algo}\label{alg:15}
  Применим локальный поиск с помощью $V_k$, определённого следующим образом: $\pi' \in V_{\pi}$, если для некоторого $j \neq k$,
  \[\pi' = (\pi_1,\ldots,\pi_j,\pi_k,\pi_{j+1},\ldots,\pi_{k-1},\pi_{k+1},\ldots)\]
  или
  \[\pi'=(\pi_1,\ldots,\pi_{k-1},\pi_{k+1},\ldots,\pi_j,\pi_k,\pi_{j+1},\ldots).\]

  Другими словами, $\pi_i'$ получается из $\pi$ с помощью изменения позиции одной вершины. Например, $(1, 2, 3, 6, 4, 5, 7)$ и $(1, 3, 4, 5, 2, 6, 7)$ являются соседями $(1, 2, 3, 4, 5, 6, 7)$.

  Алгоритм \ref{alg:15} является $0.5$-приближением. Докажем это утверждение, показав, что любое решение, содержащее менее половины общего веса рёбер, не может быть получено с помощью локально оптимальной перестановки. Такое решение должно иметь по крайней мере одну вершину таким образом, чтобы общий вес рёбер, инцидентных с ней в индуцированном подграфе, был строго меньше половины общего веса
  рёбер, инцидентных с ней в $G$. Но в этом случае лучшая перестановка может быть получена путем перемещения этой вершины либо в первую, либо в последнюю позицию (один из этих вариантов добавит больше веса, чем то, что теряется при изменении). Таким образом, предлагаемое решение не может быть локально оптимальным.
\end{algo}

\begin{example}\label{examp:16}
  Пусть $A = \condset{(i, i+1)}{i=1,\ldots,n-1}$. Граф ациклический, и оптимальное решение содержит все $n-1$ рёбер. Однако перестановка $(n-1, n, n-3, n-2,\ldots, 5, 6, 3, 4, 1, 2)$ является локально оптимальной и индуцирует подграф с $\frac{n}{2}$ рёбрами $(n-1, n), (n-3, n-2), \ldots, (5, 6), (3, 4), (1, 2)$. Любое локальное изменение в перестановке может добавить не более одного ребра, но, несомненно, также потеряет одно ребро.
\end{example}

\begin{algo}\label{alg:17}
  Сделаем локальный поиск с $V_{\pi}$, определенным следующим образом: $\pi' \in V_{\pi}$, если для некоторого $j < k$,
  \[\pi' = (\pi_1, \ldots, \pi_{j-1}, \pi_k, \pi_{j+1}, \ldots, \pi_{k-1}, \pi_j, \pi_{k+1}, \ldots).\]
\end{algo}

Другими словами, $\pi'$ получается из $\pi$ путем переставления двух вершин друг с другом.
Например, перестановка $(1, 6, 3, 4, 5, 2, 7)$ является соседом $(1, 2, 3, 4, 5, 6, 7)$.

Алгоритм \ref{alg:17} является $0.5$-приближением. Докажем это утверждение, показав, что любое решение, содержащее менее половины общего веса рёбер, не может быть получено локально оптимальной перестановкой. Достаточно показать, что вес подграфа, индуцированного локально оптимальной перестановкой $\pi$, по меньшей мере так же хорош, как и вес подграфа, индуцированного обратной перестановкой $\tilde{\pi}$(поскольку сумма двух равна общему весу рёбер в $G$). Обратную перестановку $\tilde{\pi}$ можно получить из $\pi$, меняя местами два элемента между собой $\frac{n}{2}$ подряд: сначала поменяем местами $\pi(1)$ и $\pi(n)$, затем $p(2)$ и $\pi(n-1)$ и так далее. Влияние второй замены на вес индуцированного подграфа не зависит от первой замены, поскольку оно влияет только на рёбра, два конца которых отличаются как от $\pi(1)$, так и от $\pi(n)$. Аналогично, каждая последующая перестановка влияет на решение таким же образом, как она
повлияет на него, если мы сделаем это непосредственно с исходной перестановкой $\pi$. Поскольку $\pi$ является локальным максимумом, ни одна из этих перестановок не увеличивает вес индуцированного подграфа. Это доказывает наше утверждение.

\begin{example}
  Рассмотрим ещё раз пример \ref{examp:16}. Перестановки, описанная там, также локально оптимальна по отношению к алгоритму \ref{alg:17}.
\end{example}

Даже если мы допускаем бóльшую окрестность, в которой допускается до $k$ перестановок для некоторого фиксированного $k$, расширение примера \ref{examp:16} все равно применимо. Пусть $V = V_1 \cup V_2 \cup \ldots \cup V_{2l}$, где $|V_i| = m \gg k$ для $i=1,\ldots,2l$. Из каждой вершины в $V_i$ для
четных $i$ есть рёбра, идущие ко всем $m$ вершинам в $V_{i+1}$. Из каждой вершины в $V_i$ для нечётных
$i$ есть $m-k$ рёбер, ведущих к вершинам в $V_{i+1}$. Эти рёбра выбраны так, чтобы для вершины в $V_i$ при чётном $i$ было ровно $m-k$ рёбер, входящих из $V_{i-1}$. График является ациклическим и имеет $lm^2 + lm(m-k)$ рёбер. Рассмотрим перестановку, в которой вершины из каждого $V_i$ были последовательными, а порядок множеств был $V_{2l-1}, V_{2l}, V_{2l-3}, V_{2l-2}, \ldots, V_3, V_4, V_1, V_2$. Из каждой вершины в $V_i$ при чётных $i$ решение, полученное перестановкой, содержит все $m$ рёбер, исходящих из неё. Решение не содержит ни одного из рёбер, идущих от $V_i$ к $V_{i+1}$ для нечетных $i$. Таким образом, оно содержит $lm$ рёбер, что составляет примерно половину оптимального количества. Любое изменение местоположения любого отдельного индекса влечет за собой потерю по меньшей мере $k$ рёбер. Следовательно, при перестановке не более $k$ вершин выигрыш невозможен.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Благодарности}

Доказательство того, что алгоритм \ref{alg:17} имеет 0.5-приближение, принадлежит Нили Гутман.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \cite{berger1990approximation}
% \printbibliography

\include{bibliography}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
